Project Resurrection: Architecting "Artificial Unintelligence" via Agentic SystemsA Comprehensive Research & Implementation Report1. Archeological Reconstruction: The Lost Game and the OpportunityThe digital landscape of 2023 witnessed the brief but notable rise of Artificial Unintelligence, a browser-based party game developed by Pittsburgh-based software engineer Alexander Grattan.1 The application appeared during the initial explosive growth of consumer-facing generative AI, positioning itself as a satirical counterpoint to the prevailing narrative of "AI perfection." While the original platform, artificialunintelligence.gg, is no longer active 3, a forensic analysis of the developer's portfolio, Product Hunt listings, and scattered user discussions allows for a high-fidelity reconstruction of its mechanics, social dynamics, and likely failure modes.This report serves as a foundational architectural document for recreating this experience. However, the objective is not merely replication; it is modernization. We aim to leverage the massive leaps in "Agentic" development environments—specifically Google’s Antigravity and Codeium’s Windsurf—alongside the cost-efficiency of the Gemini 2.5 Flash ecosystem to build a sustainable, mobile-first web application.1.1 The "Jackbox" Paradigm and the "Unintelligence" MechanicThe core gameplay loop of Artificial Unintelligence was explicitly modeled after Quiplash, a standout title in the Jackbox Party Pack series.4 In Quiplash, players are given a prompt (e.g., "Something you’d be surprised to see a donkey doing") and must write a witty text response. The humor is derived from the human player's ability to be clever, absurd, or shocking.Grattan’s innovation was to replace the text response with an AI-generated image.2 Players would receive a prompt—such as "The creature hidden in IKEA" or "A canceled children's toy"—and then input a text description into an AI generator to visualize that concept. The resulting images were often glitchy, surreal, or hilariously literal interpretations of the user's intent. The game then pitted two images against each other, asking the lobby to vote for the funniest or most accurate representation.The "Unintelligence" Paradox:A critical insight for our reconstruction is the game's title: Artificial Unintelligence. The comedic value relied heavily on the limitations of 2022-2023 era models (likely early Stable Diffusion or DALL-E 2). These models struggled with spatial coherence, text rendering, and complex prompt adherence, resulting in "cursed" imagery that provoked laughter.5This presents a unique design challenge for 2025. Modern models like Imagen 3 and Gemini 2.5 Flash are significantly more "intelligent." They tend to produce polished, high-fidelity, and coherent results.6 If a player prompts "A dog eating pizza," a modern model will generate a photorealistic dog eating pizza. The "Unintelligence" factor—the glitchy, bizarre interpretation—is lost. Therefore, our replication strategy must involve "lobotomizing" the prompt engineering. We must instruct our AI agents to build a prompt wrapper that forces the model into a "lower fidelity" or "surrealist" mode to capture the original game's chaotic spirit.1.2 The Failure Analysis: Why Did It Die?Understanding why the original game shut down is essential to ensuring the longevity of the resurrection. While no official post-mortem exists, the economic and technical constraints of the era point to two fatal bottlenecks:BottleneckDescription2023 Context2025 Solution (Our Strategy)Unit EconomicsThe cost per generation was prohibitively high for a free game.DALL-E 2 / SD APIs cost ~$0.02–$0.04 per image. A single 8-player game (3 rounds) could generate 48 images, costing ~$1.50 in pure API fees per session.Gemini 2.5 Flash offers massively reduced pricing, often pennies per million tokens, or low-cost image tiers.Latency Drift"Party" momentum dies if players wait too long.Generating a 1024x1024 image took 10–20 seconds. Synchronizing 8 concurrent generations created massive lobby wait times.Gemini Flash models are optimized for low-latency inference, reducing generation time to 3–5 seconds.InfrastructureReal-time websocket management is complex and expensive to scale.Hosting stateful Node.js servers on platforms like Heroku or AWS required fixed monthly costs even with zero users.Modern "Serverless WebSockets" (PartyKit, Cloudflare Durable Objects) or optimized container platforms (Railway) offer scale-to-zero capabilities.The reconstruction will address these explicitly by utilizing the @google/genai SDK to access the fastest, cheapest tiers of Gemini, and by architecting a lightweight, stateless-where-possible backend managed by our AI agents.2. The Agentic Architecture: Tools and PhilosophyWe are entering a new paradigm of software engineering where the developer transitions from a "writer of code" to an "architect of agents." This project will utilize two distinct "Agentic IDEs": Google Antigravity and Windsurf. Understanding their distinct strengths is crucial for the workflow.2.1 Google Antigravity: The OrchestratorGoogle Antigravity is an "agent-first" development platform that evolves the traditional IDE into a "Mission Control" interface.8 Unlike standard coding assistants that autocomplete syntax, Antigravity is designed to manage autonomous agents that can plan, code, and browse the web.Role in Project: Antigravity will be used for the "Macro" tasks. We will use it to scaffold the entire project structure, set up the Next.js framework, configure the Tailwind design system, and implement the broad strokes of the Game Loop logic.Key Mechanism: Rules & Workflows: Antigravity relies on specific Markdown files (.agent/rules and .agent/workflows) to understand constraints.11Rules: These act as "Immutable Laws." For example, a rule might state: "All UI components must be mobile-responsive and use Tailwind CSS."Workflows: These are "Standard Operating Procedures." We can define a workflow for "New Feature Implementation" that guides the agent through planning, coding, and verification steps.Constraint: Antigravity rules files are limited to 12,000 characters each.11 This high limit allows us to provide extensive documentation about the original game mechanics directly to the agent.2.2 Windsurf: The TacticianWindsurf, powered by Codeium's "Cascade" agent, excels at "Flow" state development.13 It maintains a deep, real-time awareness of the codebase and the user's cursor location.Role in Project: Windsurf will be used for the "Micro" tasks. This includes debugging the WebSocket race conditions, fine-tuning the CSS animations for the voting screen, and iterating on the "Unintelligence" prompt engineering.Key Mechanism: Memories & .windsurfrules: Windsurf utilizes a file named .windsurfrules (or .windsurf/rules in newer versions) to define project context.15Constraint: Windsurf's rule files are limited to 6,000 characters.16 This means our instructions for Windsurf must be more concise than those for Antigravity.Cascade Flow: Windsurf allows for a "Tab-Tab-Ship" workflow where the AI predicts the next logical code block based on the entire project context, which is essential for the rapid iteration of the game's UI.143. The Technical Blueprint: Modern T3 StackTo replicate Artificial Unintelligence effectively, we must select a technology stack that is robust, cost-effective, and highly represented in the training data of the LLMs driving our agents (Gemini 3 Pro, Claude 3.5 Sonnet). A stack that is "familiar" to the AI reduces hallucinations and increases code quality.3.1 Frontend: Next.js 14+ (App Router)We will strictly use Next.js 14 with the App Router architecture.Justification: The App Router's clear separation of Server Components and Client Components is ideal for this application. The "Lobby" and "Game Room" are inherently interactive Client Components, while the initial landing pages can be optimized Server Components.Agent Instruction: We must explicitly instruct the agents to use the src/app directory structure and to favor lucide-react for iconography, as this library is lightweight and standard in modern Next.js builds.3.2 Styling: Tailwind CSS (Mobile First)The target delivery vector is a "Mobile Web App." It must feel like a native app when played on a phone browser (Safari/Chrome).Justification: Tailwind's utility-first approach allows agents to generate styling incredibly fast.Agent Instruction: "All clickable elements must have a minimum height of 44px (touch target size). Use touch-manipulation class to prevent double-tap zoom delay. Avoid hover states; use active states instead."3.3 Backend: Custom Node.js Server with Socket.ioThis is the most critical architectural decision. While Next.js creates its own server, standard "Serverless" functions (Vercel API Routes) are stateless and terminate connections quickly, making them poor candidates for a real-time WebSocket game.Architecture: We will implement a Custom Server pattern. We will wrap the Next.js application in an Express server that also attaches a Socket.io instance.State Management: For the MVP (Minimum Viable Product), game state (lobbies, scores, players) will be stored in-memory within the Node.js process.Risk: If the server restarts, all games are lost.Mitigation: This is acceptable for a casual party game. For scale, we can instruct the agents to implement an adapter for Redis.173.4 The AI Engine: Google Gemini API (@google/genai)We will use the Google Gen AI SDK for Node.js (@google/genai) to interface with the models.Model Selection: Gemini 2.5 Flash (codenamed "Nano Banana") or Imagen 3.7 Flash is prioritized for its speed and low cost.Integration: The backend will handle all API calls. The frontend will never expose the API key.Data Transport: To avoid the complexity and cost of S3 bucket management for temporary game images, the server will receive the image as a binary buffer, convert it to a Base64 Data URI, and emit it directly to the clients via the WebSocket connection.Constraint: We must resize images to ~512x512 to ensure the WebSocket payload size stays manageable and doesn't induce lag on mobile networks.4. Implementation Strategy: The Reference NotesThe core of this request is the creation of "Reference Notes"—markdown files that serve as the brain for the AI agents. Below are the full text contents for these files. You should create a folder named Reference_Notes and populate it with these exact files.4.1 Reference_Notes/01_GAME_DESIGN_DOCUMENT.mdThis file serves as the "source of truth" for the game's logic. Both Antigravity and Windsurf will reference this to ensure they are building the right game.Game Design Document: Artificial Unintelligence (Resurrection)1. Executive Summary"Artificial Unintelligence" is a multiplayer browser-based party game (3-8 players) where players respond to humorous prompts by generating AI images. The goal is to create images that are funny, "unintelligent," or absurdist. The game emphasizes speed, humor, and social interaction over artistic quality.2. TerminologyHost: The player who initiated the game session.Room Code: A 4-character uppercase alphanumeric string (e.g., "ABCD") used to join the lobby.Prompt: A scenario provided by the system (e.g., "The worst pizza topping").Generation: The AI-generated image created by a player.Battle: A head-to-head comparison of two Generations for the same Prompt.3. Game Loop & State MachinePhase 1: The Lobby (STATE_LOBBY)Entry: Players enter a Nickname and the Room Code.Avatars: Players select a simple pixel-art avatar.Start Condition: Host can press "Start Game" once 3 players have joined.Max Players: 8.Phase 2: Instruction (STATE_INSTRUCTION)Duration: 15 seconds (skippable by Host).Content: Overlay explaining: "You will be given a prompt. Type a description to generate an image. Try to be funny. The AI is not smart."Phase 3: The Prompt & Generation (STATE_GENERATING)Logic: The system assigns prompts to players. Each prompt is given to exactly two players to ensure a head-to-head battle.Example (4 Players):Prompt A -> Player 1 & Player 2Prompt B -> Player 3 & Player 4Prompt C -> Player 1 & Player 3Prompt D -> Player 2 & Player 4Action:Player types a text description.Player clicks "Generate".System Action: Server calls Gemini API. Returns Base64 image.Player views image. Can "Submit" or "Retry" (Max 1 Retry to save time/cost).Time Limit: 90 Seconds.Phase 4: The Battle (STATE_BATTLE)Logic: The system iterates through the pairs of submitted images.Display:Top: The Prompt Text.Left: Image A.Right: Image B.Action: Spectators (players not involved in the current battle) vote for their favorite.Time Limit: 15 Seconds per battle.Phase 5: The Reveal (STATE_REVEAL)Display:Winner is highlighted.Percentage of votes shown (e.g., "60% vs 40%").Player names revealed (e.g., "Player 1 generated this").Scoring:+1000 Points for winning the battle.+100 Points for every vote received.+500 Points "Pity Bonus" if you get 0 votes (optional, for humor).Phase 6: Game Over (STATE_GAME_OVER)Display: Leaderboard ranking players by score.Actions: "Play Again" (same players, new prompts) or "New Game" (kick to lobby).4. Technical ConstraintsMobile First: UI controls must be large and accessible on smartphones.Latency: Image generation must happen under 5 seconds.Disconnection: If a player disconnects, their submisisons remain. If they reconnect, they rejoin the session via session ID or cookie.4.2 Reference_Notes/02_SYSTEM_ARCHITECTURE.mdThis file provides the technical blueprint. It explicitly instructs the agents on the chosen stack and patterns.System Architecture: Artificial Unintelligence1. Technology StackFrontend Framework: Next.js 14 (App Router).Language: TypeScript (Strict Mode).Styling: Tailwind CSS.Server: Node.js Custom Server (Express + Socket.io).AI Integration: @google/genai SDK.2. Directory StructureThe project must adhere to this structure to ensure Agent navigation consistency:text/artificial-unintelligence├── /src│   ├── /app              # Next.js App Router pages│   ├── /components       # React Components│   │   ├── /game         # Game-specific components (Lobby, Voting, etc.)│   │   ├── /ui           # Reusable UI atoms (Buttons, Inputs)│   ├── /hooks            # Custom hooks (useSocket, useGameState)│   ├── /lib              # Utilities (Game logic helpers)│   ├── /services         # API services (Gemini wrapper)│   └── /types            # TypeScript interfaces├── /server               # Backend Logic│   ├── server.ts         # Entry point│   ├── socket.ts         # Socket.io handler│   └── roomManager.ts    # Game State Logic class├──.agent                # Antigravity Config├──.windsurf             # Windsurf Config└── package.json
## 3. Communication Protocol (WebSocket)
We use a **Server-Authoritative** state synchronization pattern.
*   The **Server** holds the "True" state (`RoomState`).
*   The **Client** is a "Dumb View." It renders whatever state the server emits.
*   **Events:**
    *   `CLIENT_JOIN_ROOM` -> `SERVER_PLAYER_JOINED`
    *   `CLIENT_SUBMIT_PROMPT` -> `SERVER_PROMPT_ACCEPTED`
    *   `SERVER_STATE_UPDATE` (Broadcasts full state delta)

## 4. AI Service Integration
*   **File:** `src/services/aiService.ts`
*   **SDK:** Use `@google/genai`.
*   **Function Signature:** `generateImage(prompt: string): Promise<string>`
*   **Output:** Returns a Base64 Data URI string.
*   **Safety:** Errors must be caught. If the API blocks a prompt (Safety Filter), return a predefined "CENSORED" placeholder image rather than throwing an error. This preserves the game flow.
4.3 Reference_Notes/03_GEMINI_PROMPT_ENGINEERING.mdThis file contains the "secret sauce" for recreating the "Unintelligence" aesthetic.Gemini Prompt Engineering StrategyObjectiveReplicate the "glitchy," "surreal," and "lo-fi" aesthetic of early AI models using modern, high-fidelity models (Gemini 2.5 Flash / Imagen 3).The "Unintelligence" WrapperWe cannot send the user's prompt raw. We must wrap it to induce a specific style.User Input: "A cat eating pizza"**System Prompt Construction:**typescriptconst BASE_PROMPT = userPrompt;const STYLE_MODIFIERS = ["digital art style","low fidelity","slightly distorted","vibrant colors","surreal humor","glitch art aesthetic","amateur photoshop style"].join(", ");const FINAL_PROMPT = ${BASE_PROMPT}. ${STYLE_MODIFIERS}. Make it look funny and slightly chaotic.;
## Model Configuration
*   **Model Name:** `gemini-2.5-flash` (or `imagen-3.0-generate-001`).
*   **Aspect Ratio:** `1:1` (Square is best for mobile layouts).
*   **Safety Settings:**
    *   Set `HARM_CATEGORY_SEXUALLY_EXPLICIT` to `BLOCK_ONLY_HIGH`.
    *   Set `HARM_CATEGORY_HATE_SPEECH` to `BLOCK_MEDIUM_AND_ABOVE`.
    *   *Reasoning:* Party games often involve "edgy" humor. Strict safety filters will ruin the experience. We rely on the social contract of the private room for moderation.

## Fallback Mechanism
If the API returns a 400 or 500 error (or a strict safety block):
1.  Log the error on the server.
2.  Return `assets/images/error_robot.png`.
3.  Client displays this image. It acts as a "Badge of Honor" for the player (i.e., "Your prompt was too crazy for the AI").
4.4 Reference_Notes/04_AGENT_RULES_ANTIGRAVITY.mdThis content goes into .agent/rules/global.md in Antigravity. Note the strict adherence to the 12,000 character limit.11Antigravity Global Rules1. Persona & ContextYou are an expert Senior Software Architect building "Artificial Unintelligence," a mobile party game. You value robust, simple code over complex abstractions. You strictly follow the "Mobile First" design philosophy.2. Workflow IntegrationAlways check Reference_Notes/01_GAME_DESIGN_DOCUMENT.md before implementing game logic.Always check Reference_Notes/02_SYSTEM_ARCHITECTURE.md for file placement.3. Coding StandardsTypes: Use explicit TypeScript interfaces for all Socket payloads. Define these in src/types/socket.ts.Styling: Use Tailwind CSS.Constraint: Do not use arbitrary values (e.g., w-[123px]) unless absolutely necessary. Use standard tokens (w-32, w-full).Layout: Use Flexbox (flex flex-col) for almost all layout needs.Components: Functional components only. Use React.memo only if performance issues arise.4. Interaction GuidelinesWhen I ask to "Scaffold the project," execute the standard Next.js + Express setup.When I ask to "Implement the Lobby," focus on the RoomManager class in the backend and the LobbyScreen component in the frontend.5. Deployment AwarenessThe code must be deployable to a containerized environment (like Railway or Render).Ensure PORT is read from environment variables (`process.env.PORT || 3000`).4.5 Reference_Notes/05_WINDSURF_RULES.mdThis content goes into .windsurfrules in the project root. Note the 6,000 character limit.16Windsurf RulesProject ContextBuilding "Artificial Unintelligence," a Next.js + Socket.io party game.Critical ConstraintsMobile UX: All buttons min-height 44px. No hover states.Socket Safety: When editing server/socket.ts, always verify the corresponding listener in src/hooks/useSocket.ts. Keep events synced.AI Integration: Use @google/genai. Do NOT use openai or google-generative-ai.Files:Game Logic: server/roomManager.tsFrontend: src/components/game/*MemoriesWe are using Gemini 2.5 Flash for image generation.We pass images as Base64 strings.The game has 5 states: LOBBY, INSTRUCTION, GENERATING, BATTLE, REVEAL.WorkflowIf I ask for a "Refactor," prioritize readability and splitting large components.If I ask for "Debug," look for race conditions in the useEffect hooks handling socket events.5. Execution: The "Agentic" WorkflowThis section details the step-by-step process of using the tools and the Reference Notes to build the application. This replicates the workflow of a professional "Agent Architect."Phase 1: Inception & Scaffolding (Antigravity)Tool: Google AntigravityContext: Global Rules loaded.Initialization: Create a new project in Antigravity. Import the Reference_Notes folder into the workspace.The Prompt:"Agent, read the SYSTEM_ARCHITECTURE.md and GAME_DESIGN_DOCUMENT.md. Scaffold the Next.js application with a custom Express server as described. Install all necessary dependencies including socket.io, express, tailwindcss, and @google/genai. Structure the folders according to the architecture guide."Verification: The agent should generate the package.json, install node modules, and create the directory tree. It should create a server/server.ts that initializes Next.js and listens on a port.Phase 2: The Logic Core (Antigravity)Tool: Google Antigravity (Agent Manager View)The Prompt:"Implement the RoomManager class in server/roomManager.ts. It needs to handle creating rooms, adding players, and managing the state transitions from LOBBY to GENERATING. Use the state machine definitions in the GDD. Use in-memory storage for now."Insight: Antigravity excels here because it can create multiple files (roomManager.ts, types/game.ts) simultaneously and ensure they import each other correctly.Phase 3: The UI & Interaction (Windsurf)Tool: Windsurf (Cascade Agent)Reasoning: UI development requires rapid iteration ("Does this button look right?"). Windsurf's synchronous chat is better for this.Transition: Open the project folder in Windsurf. Ensure .windsurfrules is active.The Prompt:"Cascade, I need to build the LobbyScreen component. It should show the Room Code in big text, a list of joined players with their avatars, and a 'Start Game' button that is only visible to the host. Use Tailwind to make it look like a retro pixel-art game."Refinement:"The avatar list looks cramped on mobile. Change the grid to 2 columns and add more padding."Phase 4: The Generative Integration (Windsurf)Tool: WindsurfFocus: src/services/aiService.tsThe Prompt:"Implement the generateImage function using the @google/genai SDK. Refer to GEMINI_PROMPT_ENGINEERING.md for the specific prompt wrapper. Handle the SafetySetting to ensure we don't crash on edgy prompts."Testing:"Create a temporary test script scripts/test-gen.ts that calls this function with the prompt 'A sad clown' and saves the result to test.png. Run it in the terminal so I can verify the API key works."Phase 5: The "Unintelligence" TuningThis is the final polish step. You play the game (self-test) and evaluate the humor.Observation: "The images are too good. They look like stock photos."Action: Edit GEMINI_PROMPT_ENGINEERING.md. Add modifiers like "badly drawn," "child's drawing," or "MS Paint style."Re-Prompt Windsurf: "Update the prompt wrapper in aiService.ts to include the new modifiers from the markdown file."6. Deep Dive: The Gemini 2.5 Flash ImplementationThe success of this project hinges on the Gemini 2.5 Flash model (often referred to in early 2025 documentation by internal codenames like "Nano Banana").6.1 SDK Migration WarningMany online tutorials reference google-generative-ai. This is the legacy SDK. The new standard is @google/genai.18Legacy (DO NOT USE):JavaScriptconst { GoogleGenerativeAI } = require("@google/generative-ai");
const model = genAI.getGenerativeModel({ model: "gemini-pro-vision" });
Modern (USE THIS):JavaScriptimport { GoogleGenAI } from "@google/genai";
const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });
const response = await ai.models.generateImages({ model: 'gemini-2.5-flash',... });
Why it matters: The legacy SDK does not support the unified generateImages method optimized for the newer Flash models. Using the old SDK will lead to type errors and missing features.6.2 Cost AnalysisThe "Cheap" requirement is satisfied by the Flash tier pricing structure.Gemini 1.5 Flash: ~$0.075 per 1 million input tokens.Gemini 2.5 Flash (Image Generation): Google often prices this per generation or per pixel count. Early pricing suggests ~$0.002 - $0.004 per standard image.20Projected Session Cost:8 Players x 3 Rounds = 24 Prompts.24 Images x $0.004 = $0.096 per game.This is sustainable for a hobby project or a small ad-supported web app.7. Deployment & Future Proofing7.1 ContainerizationBecause we are using a custom Node.js server for WebSockets, we cannot deploy to Vercel's standard tier (which supports Next.js but not persistent processes).Strategy: We must Dockerize the application.Agent Prompt: "Create a Dockerfile for this Next.js + Express app. Ensure it exposes port 3000 and runs the build command before starting."7.2 Hosting ProvidersRailway: Excellent support for persistent Node.js apps.Render: Good alternative.Fly.io: Best for low-latency (running the server close to the players), but higher configuration complexity.7.3 Scaling to "Product Hunt" LevelsIf the game goes viral again:Redis Adapter: We must move the in-memory game state to a Redis instance. This allows us to run multiple server instances (horizontal scaling) while sharing game state.Agent Instruction: "Refactor RoomManager to use ioredis for state storage instead of a local Map."Rate Limiting: Viral traffic will hit the Gemini API rate limits.Strategy: Implement a standard Token Bucket rate limiter or a simple FIFO queue for image generation requests.8. ConclusionRecreating Artificial Unintelligence is a masterclass in modern Agentic Development. By shifting the workload from "writing code" to "writing rules," we can construct a complex, real-time multiplayer system with advanced AI integration in a matter of days. The key lies not in the coding, but in the Reference Notes—the structured knowledge base that empowers Antigravity and Windsurf to act as competent domain experts.The combination of the Modern T3 Stack, WebSocket architecture, and Gemini 2.5 Flash creates a robust platform that solves the economic and technical failures of the original game, ensuring that "Unintelligence" can live on as a sustainable, hilarious party experience.